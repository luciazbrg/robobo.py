
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Robobo &#8212; Robobo.py  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="canonical" href="http://www.sphinx-doc.org/en/master/_modules/Robobo.html" />

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
<!--
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="../usage/installation.html">Get it</a></li>
    <li><a href="../contents.html">Docs</a></li>
    <li><a href="../develop.html">Extend/Develop</a></li>
  </ul>
-->
  <div>
    <a href="../index.html">
      <img src="../_static/logo_robobo.png" alt="Robobo" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Home</a></li>
<!--
        <li><a href="../index.html">Home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>
-->

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Robobo</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Robobo</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">remotelib</span> <span class="kn">import</span> <span class="n">Remote</span>
<span class="kn">from</span> <span class="nn">utils.Wheels</span> <span class="kn">import</span> <span class="n">Wheels</span>
<span class="kn">from</span> <span class="nn">utils.Note</span> <span class="kn">import</span> <span class="n">Note</span>
<span class="kn">from</span> <span class="nn">utils.Acceleration</span> <span class="kn">import</span> <span class="n">Acceleration</span>
<span class="kn">from</span> <span class="nn">utils.Orientation</span> <span class="kn">import</span> <span class="n">Orientation</span>
<span class="kn">from</span> <span class="nn">utils.Tap</span> <span class="kn">import</span> <span class="n">Tap</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Robobo</span><span class="p">:</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new Robobo.js library instance.</span>

<span class="sd">        :param ip: The IP address of the Robobo robot.</span>

<span class="sd">        :type ip: string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span> <span class="o">=</span> <span class="n">Remote</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>

<div class="viewcode-block" id="Robobo.connect"><a class="viewcode-back" href="../robobo.html#Robobo.Robobo.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Establishes a remote connection with the Robobo indicated by the IP address associated to this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">wsStartup</span><span class="p">()</span></div>

<div class="viewcode-block" id="Robobo.disconnect"><a class="viewcode-back" href="../robobo.html#Robobo.Robobo.disconnect">[docs]</a>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disconnects the library from the Robobo robot.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pauses the program for the specified time. After that time, next instruction is executed.</span>

<span class="sd">        :param seconds: Time to wait in seconds (&gt;0). Decimals like 0.2 are allowed.</span>

<span class="sd">        :type seconds: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moveWheelsByTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rSpeed</span><span class="p">,</span> <span class="n">lSpeed</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves Robobo wheels during the specified time, each one at the specified speed.</span>

<span class="sd">        :param rSpeed: Speed factor for the right wheel [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>
<span class="sd">        :param lSpeed: Speed factor for the left wheel [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>
<span class="sd">        :param duration: Duration of the movement in seconds (&gt;0). Decimals like 0.2 are allowed.</span>
<span class="sd">        :param wait: If true, the instruction is executed in blocking mode. If false, it&#39;s executed in non-blocking mode. For more information, see: :ref:`blocking`.</span>

<span class="sd">        :type rSpeed: int</span>
<span class="sd">        :type lSpeed: int</span>
<span class="sd">        :type duration: float</span>
<span class="sd">        :type wait: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveWheelsWait</span><span class="p">(</span><span class="n">rSpeed</span><span class="p">,</span> <span class="n">lSpeed</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveWheels</span><span class="p">(</span><span class="n">rSpeed</span><span class="p">,</span> <span class="n">lSpeed</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moveWheels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rSpeed</span><span class="p">,</span> <span class="n">lSpeed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves Robobo wheels, each one at the specified speed.</span>
<span class="sd">        </span>
<span class="sd">        :param rSpeed: Speed factor for the right wheel [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>
<span class="sd">        :param lSpeed: Speed factor for the left wheel [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>
<span class="sd">        </span>
<span class="sd">        :type rSpeed: int</span>
<span class="sd">        :type lSpeed: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveWheels</span><span class="p">(</span><span class="n">rSpeed</span><span class="p">,</span> <span class="n">lSpeed</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stopMotors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops the movement of the wheels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveWheels</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moveWheelsByDegrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wheel</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves Robobo wheels by some degrees at the specified speed.</span>

<span class="sd">        :param wheel: Wheel or wheels to move.</span>
<span class="sd">        :param degrees: Degrees to move the wheel or wheels (&gt;0).</span>
<span class="sd">        :param speed: Speed factor for the movement [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>

<span class="sd">        :type wheel: Wheels</span>
<span class="sd">        :type degrees: int</span>
<span class="sd">        :type speed: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveWheelsByDegreeWait</span><span class="p">(</span><span class="n">wheel</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">movePanTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the PAN of the base to the specified position at the specified speed.</span>

<span class="sd">        :param degrees: Position in degress of the PAN [-160..160]. See: :ref:`pan`.</span>
<span class="sd">        :param speed: Speed factor for the movement [0..100]. 100 is the maximum speed reachable, while 0 means no movement.</span>
<span class="sd">        :param wait: If true, the instruction is executed in blocking mode. If false, it&#39;s executed in non-blocking mode. For more information, see: :ref:`blocking`.</span>

<span class="sd">        :type degrees: int</span>
<span class="sd">        :type speed: int</span>
<span class="sd">        :type wait: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">movePanWait</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">movePan</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moveTiltTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the TILT of the base to the specified position at the specified speed.</span>

<span class="sd">        :param degrees: Position in degrees of the TILT [5..105]. See: :ref:`tilt`.</span>
<span class="sd">        :param speed: Speed factor for the movement [0..100]. 100 is the maximum speed reachable, while 0 means no movement.</span>
<span class="sd">        :param wait: If true, the instruction is executed in blocking mode. If false, it&#39;s executed in non-blocking mode. For more information, see: :ref:`blocking`.</span>
<span class="sd">            </span>
<span class="sd">        :type degrees: int</span>
<span class="sd">        :type speed: int</span>
<span class="sd">        :type wait: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveTiltWait</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">moveTilt</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">speed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setLedColorTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">led</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the color of a LED of the base.</span>

<span class="sd">        :param led: LED to set the color of.</span>
<span class="sd">        :param color: New color of the LED.</span>

<span class="sd">        :type led: LED</span>
<span class="sd">        :type color: Color</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLedColor</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resetWheelEncoders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the encoders of the wheels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetEncoders</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">playNote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Robobo play a musical note.</span>

<span class="sd">        :param note: Note to play index following the Anglo-Saxon notation, allowing 133 possible notes. The following scheme shows the equivalency in the range 48 to 59:</span>

<span class="sd">        ====  ==== ====  ==== ====  ====  ==== ==== ==== ====  ====  ====</span>
<span class="sd">        DO    DO#  RE    RE#  MI    FA    FA#  SOL  SOL# LA    LA#   SI</span>
<span class="sd">        C     Cs   D     Ds   E     F     Fs   G    Gs   A     As    B</span>
<span class="sd">        48    49   50    51   52    53    54   55   56   57    58    59</span>
<span class="sd">        ====  ==== ====  ==== ====  ====  ==== ==== ==== ====  ====  ====</span>

<span class="sd">        :param duration: Duration of the note in seconds (&gt;0). Decimals like 0.2 are allowed.</span>
<span class="sd">        :param wait: If true, the instruction is executed in blocking mode. If false, it&#39;s executed in non-blocking mode. For more information, see: :ref:`blocking`.</span>

<span class="sd">        :type note: int</span>
<span class="sd">        :type duration: float</span>
<span class="sd">        :type wait: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">playNote</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">wait</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">playSound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sound</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Robobo play the specified emotion sound.</span>

<span class="sd">        :param sound: The emotion sound to play.</span>

<span class="sd">        :type sound: Sounds</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">playEmotionSound</span><span class="p">(</span><span class="n">sound</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sayText</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">speech</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Robobo say the specified text.</span>

<span class="sd">        :param speech: The text to say.</span>
<span class="sd">        :param wait: If true, the instruction is executed in blocking mode. If false, it&#39;s executed in non-blocking mode. For more information, see: :ref:`blocking`.</span>

<span class="sd">        :type speech: string</span>
<span class="sd">        :type wait: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">talk</span><span class="p">(</span><span class="n">speech</span><span class="p">,</span> <span class="n">wait</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setStreamFps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Sets the stream fps. These are the number of frames per second sent from the smartphone to the computer. Default value is 60, buf effective value is usually lower (around 20), depending on the smartphone.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>

<span class="sd">        :param fps: New upper limit of the stream fps. Takes positive values.</span>

<span class="sd">        :type fps: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setStreamFps</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setCameraFps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Sets the camera fps. These are the number of frames per second read by the smartphone camera. Default value is 60, buf effective value is usually lower (around 20), depending on the smartphone.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>

<span class="sd">        :param fps: New upper limit of the camera fps. Takes positive values.</span>

<span class="sd">        :type fps: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setCameraFps</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setFrontCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Makes Robobo use the frontal camera.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setCamera</span><span class="p">(</span><span class="s2">&quot;front&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setBackCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Makes Robobo use the back camera.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setCamera</span><span class="p">(</span><span class="s2">&quot;back&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">startStream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the camera streaming.</span>
<span class="sd">        | Camera streaming is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | In order to use this function, it&#39;s neccesary to download the project and follow the instructions from the `stream repository &lt;https://github.com/mintforpeople/robobo-python-video-stream&gt;`_.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startStream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopStream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the camera streaming.</span>
<span class="sd">        | Camera streaming is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopStream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startFaceDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the face detection.</span>
<span class="sd">        | Face detection is started by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.stopFaceDetection`, :class:`~Robobo.readFaceSensor`, :class:`~Robobo.resetFaceSensor`, :class:`~Robobo.whenAFaceIsLost`, :class:`~Robobo.whenANewFaceIsDetected`.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startFaceDetection</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopFaceDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the face detection.</span>
<span class="sd">        | Face detection is started by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startFaceDetection`.</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopFaceDetection</span><span class="p">()</span>

<div class="viewcode-block" id="Robobo.startObjectRecognition"><a class="viewcode-back" href="../robobo.html#Robobo.Robobo.startObjectRecognition">[docs]</a>    <span class="k">def</span> <span class="nf">startObjectRecognition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the object recognition.</span>
<span class="sd">        | Object recognition is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.stopObjectRecognition`, :class:`~Robobo.readDetectedObject`, :class:`~Robobo.whenAnObjectIsDetected`.        </span>
<span class="sd">        | For more information, check the `Object Recognition Wiki &lt;https://github.com/mintforpeople/robobo-programming/wiki/Real-time-object-identification&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startObjectRecognition</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">stopObjectRecognition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the object recognition.</span>
<span class="sd">        | Object recognition is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startObjectRecognition`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopObjectRecognition</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startQrTracking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the QR tracking.</span>
<span class="sd">        | QR tracking is started by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.stopQrTracking`, :class:`~Robobo.readQR`, :class:`~Robobo.whenANewQRCodeIsDetected`, :class:`~Robobo.whenAQRCodeIsDetected`, :class:`~Robobo.whenAQRCodeIsLost`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startQrTracking</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopQrTracking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the QR tracking.</span>
<span class="sd">        | QR tracking is started by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startQrTracking`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopQrTracking</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startArUcoTagDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the ArUcoTag detection.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.stopArUcoTagDetection`, :class:`~Robobo.setArucoTagSize`, :class:`~Robobo.readArucoTag`, :class:`~Robobo.whenArucoTagIsDetected`.</span>
<span class="sd">        | For more information, check the `ArUco Tag Detection Wiki &lt;https://github.com/mintforpeople/robobo-programming/wiki/ArUco-marker-detection&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startTag</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setArucoTagSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Sets the length of the side of the ArUco tag to be detected. It is important that this value fits the real tag size used, because it is used to calculate the distance from Robobo to the tag.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startArUcoTagDetection`.</span>

<span class="sd">        :param size: Size of the side of the ArUco tag in milimiters.</span>

<span class="sd">        :type size: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">changeTagSize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stopArUcoTagDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the ArUco tag detection.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startArUcoTagDetection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopTag</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startLaneDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the lane detection.</span>
<span class="sd">        | Lane detection is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.stopLaneDetection`, :class:`~Robobo.setLaneColorInversion`, :class:`~Robobo.readLaneBasic`, :class:`~Robobo.readLanePro`, :class:`~Robobo.whenALaneBasicDetected`, :class:`~Robobo.whenALaneProDetected`.</span>
<span class="sd">        | For more information, check the `Lane Detection Wiki &lt;https://github.com/mintforpeople/robobo-programming/wiki/Lane-detection-library&gt;`_.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startLane</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopLaneDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the lane detection.</span>
<span class="sd">        | Lane detection is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopLane</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startLineDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Starts the line detection.</span>
<span class="sd">        | Line detection is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~utils.Lines.Lines`, :class:`~Robobo.stopLineDetection`, :class:`~Robobo.readLine`, :class:`~Robobo.whenALineIsDetected`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startLine</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopLineDetection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the line detection.</span>
<span class="sd">        | Line detection is stopped by default.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startLineDetection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopLine</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setLaneColorInversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_on</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Toggles the color inversion for the advanced lane module. Usually, light lanes are detected against a dark background, but it is also possible to detect dark lanes against light backgrounds.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>

<span class="sd">        :param set_on: Boolean to choose if turn it on or off.</span>

<span class="sd">        :type set_on: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">set_on</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLaneColorInversionOn</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLaneColorInversionOff</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">startCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts the camera.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">startCamera</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">stopCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Stops the camera.</span>
<span class="sd">        | **Warning**: Other modules depend on the camera, so it&#39;s necessary to start it again to make use of them.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">stopCamera</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">resetClapCounter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the clap counter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetClaps</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">resetTapSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the tap sensor value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetTap</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">resetFlingSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the state of the Fling sensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetFling</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">resetColorBlobs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Resets the color blob detector. This sets to 0 the attributes of the last color blobs detected, but keeps the enabled and disabled colors the same.</span>
<span class="sd">        | See also: :class:`~Robobo.setActiveBlobs`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetBlobs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">resetFaceSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Resets the face sensor. After this function, and until a new face is detected, the face sensor will return 0 for each attribute of the face object.</span>
<span class="sd">        | See also: :class:`~Robobo.startFaceDetection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">resetFace</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setEmotionTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emotion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the emotion showed by the face of Robobo.</span>

<span class="sd">        :param emotion: New emotion to show.</span>

<span class="sd">        :type emotion: Emotions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setEmotionTo</span><span class="p">(</span><span class="n">emotion</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setActiveBlobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">custom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | **Note**: Before tracking blobs, it is highly recommended to follow the `camera calibration tutorial &lt;https://github.com/mintforpeople/robobo-programming/wiki/camera-calibration-tutorial_en&gt;`_.</span>
<span class="sd">        | Enables or disables the individual tracking of each color.</span>
<span class="sd">        | By default, green tracking is enabled and the rest are disabled.</span>
<span class="sd">        | **Warning**: Color tracking is a computationally intensive task, activating all the colors may impact performance.</span>
<span class="sd">        | See also: :class:`~Robobo.readAllColorBlobs`, :class:`~Robobo.readColorBlob`, :class:`~Robobo.resetColorBlobs`, :class:`~Robobo.whenANewColorBlobIsDetected`.</span>

<span class="sd">        :param red: If true, enables red blob tracking.</span>
<span class="sd">        :param green: If true, enables green blob tracking.</span>
<span class="sd">        :param blue: If true, enables blue blob tracking.</span>
<span class="sd">        :param custom: If true, enables custom blob tracking.</span>

<span class="sd">        :type red: bool</span>
<span class="sd">        :type green: bool</span>
<span class="sd">        :type blue: bool</span>
<span class="sd">        :type custom: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">configureBlobTracking</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">custom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setAdvancedLostBlobParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">frames</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">minarea</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Sets advanced parameters for the blob tracker.</span>

<span class="sd">        | **Warning**: Only use this function if you know what you are doing. A bad configuration might have unexpected consecuences.</span>

<span class="sd">        :param frames: Number of frames passed to consider a blob lost.</span>
<span class="sd">        :param minarea: Minimum area to consdider a Blob as a Blob.</span>
<span class="sd">        :param max_count: max_count parameter of the termcriteria.</span>
<span class="sd">        :param epsilon: epsilon parameter of the termcriteria.</span>

<span class="sd">        :type frames: int</span>
<span class="sd">        :type minarea: int</span>
<span class="sd">        :type max_count: int</span>
<span class="sd">        :type epsilon: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">advancedLostBlobConfiguration</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">minarea</span><span class="p">,</span> <span class="n">max_count</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readClapCounter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the number of claps registered since last reset.</span>

<span class="sd">        :return: The number of claps.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">claps</span>

    <span class="k">def</span> <span class="nf">readLastNote</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the last note detected by the note sensor.</span>

<span class="sd">        :return: The note read.</span>

<span class="sd">        :rtype: Note</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Note</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">lastNote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">lastNoteDuration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readIRSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the current value sensed by the specified IR.</span>
<span class="sd">        This value depends on the distance to nearby objects, being larger for shorter distances.</span>
<span class="sd">        This value also depends on ambient conditions, such as the lighting.</span>

<span class="sd">        :param id: The IR to read the value sensed from.</span>
<span class="sd">        :return: The value of the IR read.</span>

<span class="sd">        :type id: IR</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">irs</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">irs</span><span class="p">[</span><span class="nb">id</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">readAllIRSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the values of all the IR sensors.</span>

<span class="sd">        Example of use:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            irs = rob.readAllIRSensor()</span>
<span class="sd">            if irs != []:</span>
<span class="sd">                print (irs[IR.FrontR.value])</span>
<span class="sd">                print (irs[IR.FrontRR.value])</span>

<span class="sd">        :return: A dictionary returning the values of all the IR sensors of the base. \</span>
<span class="sd">                 Dictionary keys (string): IR ids (see :class:`~utils.IR.IR`). \</span>
<span class="sd">                 Dictionary values (float): The value of the IR.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">irs</span>

    <span class="k">def</span> <span class="nf">readColorBlob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last detected blob of the indicated color.</span>
<span class="sd">        | See also: :class:`~Robobo.setActiveBlobs`.</span>
<span class="sd">         </span>
<span class="sd">        :param color: Color of the blob.</span>
<span class="sd">        :type color: BlobColor</span>

<span class="sd">        :return:  The blob read.</span>
<span class="sd">        :rtype: Blob</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">blobs</span><span class="p">[</span><span class="n">color</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">readAllColorBlobs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads all the color blob data.</span>
<span class="sd">        | See also: :class:`~Robobo.setActiveBlobs`.</span>

<span class="sd">        Example of use:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            blobs = rob.readAllColorBlobs()</span>
<span class="sd">            for key in blobs:</span>
<span class="sd">                blob = blobs[key]</span>
<span class="sd">                print(blob.color)</span>
<span class="sd">                print(blob.posx)</span>
<span class="sd">                print(blob.posy)</span>
<span class="sd">                print(blob.size)</span>

<span class="sd">        :return: A dictionary returning the individual blob information. \</span>
<span class="sd">                Dictionary keys (:class:`~utils.BlobColor`): the possible colors. Dictionary values (:class:`~utils.Blob`): the blobs.</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">blobs</span>

    <span class="k">def</span> <span class="nf">readQR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last detected QR code.</span>
<span class="sd">        | See also: :class:`~Robobo.startQrTracking`.</span>

<span class="sd">        :return: The QR code read.</span>

<span class="sd">        :rtype: QRCode</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">qr</span>

    <span class="k">def</span> <span class="nf">readLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last detected line.</span>
<span class="sd">        | See also: :class:`~Robobo.startLineDetection`.</span>

<span class="sd">        :return: The line read.</span>

<span class="sd">        :rtype: Lines       </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">lines</span>

    <span class="k">def</span> <span class="nf">readLaneBasic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last detected basic lane (straight lines).</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>

<span class="sd">        :return: The lane read.</span>

<span class="sd">        :rtype: LaneBasic        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">laneBasic</span>

    <span class="k">def</span> <span class="nf">readLanePro</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last detected pro lane (Degree 2 polynomials).</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>

<span class="sd">        :return: The pro lane read.</span>
<span class="sd">        </span>
<span class="sd">        :rtype: LanePro        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">lanePro</span>

    <span class="k">def</span> <span class="nf">readOrientationSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the orientation sensor.</span>

<span class="sd">        | **Warning**: This sensor may not be available on all the devices.</span>

<span class="sd">        :return: The orientation read.</span>

<span class="sd">        :rtype: Orientation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Orientation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">yaw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">roll</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readAccelerationSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the acceleration sensor.</span>

<span class="sd">        :return: The acceleration read.</span>

<span class="sd">        :rtype: Acceleration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Acceleration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">accelx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">accely</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">accelz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readTapSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the data on the tap sensor.</span>

<span class="sd">        :return: The data read.</span>

<span class="sd">        :rtype: Tap</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Tap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">tapx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">tapy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readPanPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the current position of the PAN.</span>

<span class="sd">        :return: The position in degrees, taking values in range [-160..160]. See: :ref:`pan`.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">panPos</span>

    <span class="k">def</span> <span class="nf">readTiltPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the current position of the TILT.</span>

<span class="sd">        :return: The position in degrees, taking values in range [5..105]. See: :ref:`tilt`.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">tiltPos</span>

    <span class="k">def</span> <span class="nf">readWheelPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wheel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the current position of the specified wheel.</span>

<span class="sd">        :param wheel: The wheel to read the position of. One of Wheels.L or Wheels.R.</span>
<span class="sd">        :type wheel: Wheels</span>

<span class="sd">        :return: The position of the wheel in degrees.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wheel</span> <span class="o">==</span> <span class="n">Wheels</span><span class="o">.</span><span class="n">R</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">wheelPosR</span>
        <span class="k">elif</span> <span class="n">wheel</span> <span class="o">==</span> <span class="n">Wheels</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">wheelPosL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wheel id not valid&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readWheelSpeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wheel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current speed of the specified wheel.</span>

<span class="sd">        :param wheel: The wheel to read the position of. One of Wheels.L or Wheels.R</span>
<span class="sd">        :type wheel: Wheels</span>

<span class="sd">        :return: The current speed of the wheel [-100..100]. Absolute value 100 is the maximum speed reachable, while 0 means no movement. Positive values mean the wheel moves forwards and negative values mean it moves backwards.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">wheel</span> <span class="o">==</span> <span class="n">Wheels</span><span class="o">.</span><span class="n">R</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">wheelSpeedR</span>
        <span class="k">elif</span> <span class="n">wheel</span> <span class="o">==</span> <span class="n">Wheels</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">wheelSpeedL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wheel id not valid&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readFlingAngle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the last angle detected on the fling sensor. This angle is formed by a horizontal line and the first and last points where the finger touched the screen.</span>

<span class="sd">        :return: The angle detected in degrees.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">flingAngle</span>

    <span class="k">def</span> <span class="nf">readFlingDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the length of the last fling detected by Robobo.</span>

<span class="sd">        :return: The length of the fling in pixels.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">flingDistance</span>

    <span class="k">def</span> <span class="nf">readFlingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the duration of the last fling detected by Robobo.</span>

<span class="sd">        :return: The duration of the fling in milliseconds.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">flingTime</span>

    <span class="k">def</span> <span class="nf">readBatteryLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the battery level of the base or the smartphone.</span>

<span class="sd">        :param device: One of &#39;base&#39; or &#39;phone&#39;.</span>
<span class="sd">        :type device: string</span>

<span class="sd">        :return: The battery level of the specified device.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="s2">&quot;phone&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">phoneBattery</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">baseBattery</span>

    <span class="k">def</span> <span class="nf">readNoiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the SPL (Sound Pressure Level) value, which is a measurement of the ambient noise.</span>

<span class="sd">        :return: The SPL value in decibels.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">noise</span>

    <span class="k">def</span> <span class="nf">readBrightnessSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the ambient light level detected by the smartphone.</span>
<span class="sd">        | **Warning**: The light sensor may not be available on all the devices.</span>

<span class="sd">        :return: The brightness value in lux. It&#39;s a positive value.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">brightness</span>

    <span class="k">def</span> <span class="nf">readFaceSensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last face detected by Robobo.</span>
<span class="sd">        | See also: :class:`~Robobo.startFaceDetection`.</span>

<span class="sd">        Example of use:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">           face = robobo.readFaceSensor()</span>
<span class="sd">           print(face.distance)  #the distance to the person</span>
<span class="sd">           print(face.posX) # the position of the face in X axis</span>
<span class="sd">           print(fase.posY) # the position of the face in Y axis</span>

<span class="sd">        :return: The information of the face detected.</span>
<span class="sd">        :rtype: Face</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">face</span>

    <span class="k">def</span> <span class="nf">readArucoTag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last ArUco Tag detected by Robobo.</span>
<span class="sd">        | See also: :class:`~Robobo.startArUcoTagDetection`.</span>

<span class="sd">        :return: The Tag.</span>

<span class="sd">        :rtype: Tag</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">tag</span>

    <span class="k">def</span> <span class="nf">readDetectedObject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Reads the last object detected by Robobo.</span>
<span class="sd">        | See also: :class:`~Robobo.startObjectRecognition`.</span>

<span class="sd">        :return: The object.</span>

<span class="sd">        :rtype: DetectedObject</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">detectedObject</span>

    <span class="k">def</span> <span class="nf">whenClapIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configures the callback that is called when a new clap is detected.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setClapCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenANoteIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configures the callback that is called when a new note is detected.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setNoteCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenANewFaceIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a new face is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startFaceDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setFaceCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenANewColorBlobIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a new color blob is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.setActiveBlobs`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setBlobCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenANewQRCodeIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a new QR is detected. A QR is considered to be new if it&#39;s different to the last one detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startQrTracking`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setNewQRCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenATapIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configures the callback that is called when a new tap is detected.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setTapCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenAFlingIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configures the callback that is called when a new fling is detected.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setFlingCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenAFaceIsLost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a face is lost.</span>
<span class="sd">        | See also: :class:`~Robobo.startFaceDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLostFaceCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenAQRCodeIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a QR is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startQrTracking`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setQRCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenAQRCodeIsLost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a QR is lost.</span>
<span class="sd">        | See also: :class:`~Robobo.startQrTracking`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLostQRCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenArucoTagIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a Tag is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startArUcoTagDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setTagCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenAnObjectIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when an object is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startObjectRecognition`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setDetectedObjectCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenALineIsDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a line is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startLineDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLineCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenALaneProDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a pro lane is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLaneProCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">whenALaneBasicDetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Configures the callback that is called when a basic lane is detected.</span>
<span class="sd">        | See also: :class:`~Robobo.startLaneDetection`.</span>

<span class="sd">        :param callback: The callback function to be called.</span>

<span class="sd">        :type callback: fun</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">setLaneBasicCallback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setStatusFrequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        | Sets the frequency of the status messages coming from Robobo. Status messages are filtered by default in order to reduce network bandwidth. A higher frequency reduces the filters, so more status messages are sent and more network bandwidth is used.</span>
<span class="sd">        | This change is persistent (see: :ref:`persistent`).</span>

<span class="sd">        :param frequency: New frequency of the status messages.</span>

<span class="sd">        :type frequency: StatusFrequency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rem</span><span class="o">.</span><span class="n">changeStatusFrequency</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Home</a></li>
<!--
        <li><a href="../index.html">Home</a>&#160;|</li>
        <li><a href="../contents.html">Documentation</a> &#187;</li>
-->

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Robobo</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010, MINT.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.1.
    </div>
  </body>
</html>